# Vibe Scale

[![Vibe Score](https://img.shields.io/badge/vibe--scale-enabled-brightgreen)](https://github.com/brianmeyer/vibe-scale)

A GitHub App that analyzes pull requests for "vibe-coded" production risks. Combines **AST-based static analysis** with **LLM-powered review** to catch scaling issues, concurrency problems, and other patterns that commonly cause production failures in AI-generated or prototype code.

## What is "Vibe-Coded"?

"Vibe-coded" refers to code that:
- Was written quickly as a prototype or generated by AI without careful review
- Relies on happy-path scenarios without defensive coding
- Missing validation, error handling, or proper observability
- Has scaling blind spots (unbounded queries, N+1 patterns, no caching)

## Features

### Multi-Language AST Analysis

Vibe Scale uses **Abstract Syntax Tree (AST) parsing** for accurate, scope-aware analysis with **regex fallback** for unsupported languages:

| Language | Parser | Features |
|----------|--------|----------|
| TypeScript/JavaScript | ts-morph | Full type info, scope detection |
| Python | tree-sitter | Function/class boundaries |
| Go | tree-sitter | Goroutine detection |
| Ruby | tree-sitter | Block/method scopes |
| Others | Regex | Pattern matching fallback |

**AST advantages over regex-only:**
- Scope-aware detection (inside try/catch, loops, functions)
- Comment and string literal filtering (reduces false positives)
- Code context awareness (route handlers, module scope)
- Graceful fallback on parse errors

### Static Analysis Rules (23 Rules)

| Category | Rules |
|----------|-------|
| **Scaling** | `UNBOUNDED_QUERY`, `UNBOUNDED_COLLECTION_PROCESSING`, `MISSING_BATCHING`, `NO_CACHING`, `MEMORY_RISK`, `LOOPED_IO`, `BLOCKING_OPERATION` |
| **Concurrency** | `SHARED_FILE_WRITE`, `RETRY_STORM_RISK`, `BUSY_WAIT_OR_TIGHT_LOOP`, `CHECK_THEN_ACT_RACE`, `GLOBAL_MUTATION` |
| **Error Handling** | `UNSAFE_IO`, `SILENT_ERROR`, `ASYNC_MISUSE` |
| **Data Integrity** | `UNVALIDATED_INPUT`, `DATA_SHAPE_ASSUMPTION`, `MIXED_RESPONSE_SHAPES`, `HARDCODED_SECRET` |
| **Code Quality** | `TEMPORARY_HACK`, `CONSOLE_DEBUG` |
| **Architecture** | `STATEFUL_SERVICE`, `PROTOTYPE_INFRA` |
| **Security** | `UNSAFE_EVAL`, `HARDCODED_URL` |

### Analysis Modes

1. **PR Patch Analysis**: Analyzes changed lines in the PR diff
2. **Full File Scanning**: Critical issues anywhere in touched files (`STATEFUL_SERVICE`, `PROTOTYPE_INFRA`, `HARDCODED_SECRET`, `UNSAFE_EVAL`, `GLOBAL_MUTATION`)
3. **Baseline Repository Scan**: One-time full repo analysis for new installations

### LLM Analysis (Advisory)

Uses Groq API (llama-3.1-8b-instant) to provide additional context. **Advisory only** - does NOT affect the Vibe Score.

| Issue Kind | Description |
|------------|-------------|
| `SCALING_RISK` | Performance/cost issues as traffic grows |
| `CONCURRENCY_RISK` | Race conditions and contention |
| `ENVIRONMENT_ASSUMPTION` | Hidden infrastructure assumptions |
| `DATA_CONTRACT_RISK` | Data shape/validation issues |
| `OBSERVABILITY_GAP` | Missing logging/metrics |
| `RESILIENCE_GAP` | Missing fault tolerance |

**Token Quota Protection**: Monthly per-installation limits stored in Redis prevent runaway costs.

### Vibe Score

A 0-100 score indicating production readiness:

| Score | Label | Description |
|-------|-------|-------------|
| 90-100 | Excellent | Production ready |
| 75-89 | Good | Minor concerns |
| 60-74 | Moderate risk | Review before production |
| 40-59 | Risky | Significant issues |
| 0-39 | Critical risk | Major concerns |

**Scoring factors:**
- Scaling/concurrency/security rules have heavier penalties
- Rule level multipliers: error (1.0), warning (0.5), info (0.2)
- Configurable weight multiplier

## Configuration

Create a `.vibescale.yml` in your repository root:

```yaml
version: 1

rules:
  UNBOUNDED_QUERY:
    enabled: true
    level: error
  CONSOLE_DEBUG:
    enabled: false

files:
  ignore:
    - "tests/**"
    - "**/*.spec.ts"
  prototype_zone:
    - "playground/**"
    - "experiments/**"

scoring:
  high_risk_vibe_score: 60
  weight_multiplier: 1.0

overrides:
  - patterns:
      - "src/infra/**"
    rules:
      NO_CACHING:
        level: error
```

### Inline Suppressions

Suppress findings with comments (works in any language):

```typescript
/* vibescale-ignore-file ALL */

// vibescale-ignore-next-line UNBOUNDED_QUERY
const users = await db.users.findMany();

const data = await fetch("/api"); // vibescale-ignore-line UNSAFE_IO

// vibescale-ignore-next-line UNSAFE_IO,SILENT_ERROR
```

```python
# vibescale-ignore-file ALL

# vibescale-ignore-next-line UNBOUNDED_QUERY
users = db.query("SELECT * FROM users")
```

## Installation

### As a GitHub App

1. Create a new GitHub App with these permissions:
   - **Pull requests**: Read & Write
   - **Checks**: Read & Write
   - **Contents**: Read
   - **Issues**: Write (for high-risk comments)

2. Subscribe to webhook events: `pull_request`, `check_suite`

3. Set environment variables:
   ```bash
   # Required
   GITHUB_APP_ID=your_app_id
   GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n..."
   GITHUB_WEBHOOK_SECRET=your_webhook_secret
   REDIS_URL=redis://...

   # Optional
   GROQ_API_KEY=your_groq_api_key  # For LLM analysis
   MONTHLY_TOKEN_QUOTA=100000      # Default 100k tokens/month
   ```

4. Deploy and configure the webhook URL

### Deploy to Railway

1. Create a new project on [Railway](https://railway.app)
2. Add a **Redis** service
3. Connect your GitHub repo
4. Set environment variables (Railway auto-injects `REDIS_URL` and `PORT`)
5. Configure public networking
6. Set your GitHub App webhook URL to `https://your-app.up.railway.app/webhook`

### Local Development

```bash
# Install dependencies
npm install

# Start development server (requires Redis)
npm run dev

# Build for production
npm run build
npm run start
```

## API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/` | GET | Status page with version info |
| `/health` | GET | Health check (Redis connectivity, GitHub config) |
| `/webhook` | POST | GitHub webhook handler |

## How It Works

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  GitHub sends   │────▶│  Webhook handler │────▶│  Respond 200 OK │
│  pull_request   │     │  (verify sig)    │     │  immediately    │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                                │
                                ▼ (async background)
                        ┌──────────────────┐
                        │  Fetch PR files  │
                        │  & config        │
                        └──────────────────┘
                                │
                                ▼
                        ┌──────────────────┐
                        │  AST Analysis    │
                        │  + Regex fallback│
                        └──────────────────┘
                                │
                                ▼
                        ┌──────────────────┐
                        │  LLM Analysis    │
                        │  (if quota OK)   │
                        └──────────────────┘
                                │
                                ▼
                        ┌──────────────────┐
                        │  Compute Score   │
                        │  & Post Results  │
                        └──────────────────┘
```

## Production Features

- **Async Webhook Processing**: Responds immediately, processes in background
- **Rate Limiting**: 100 req/min (general), 60 req/min (webhooks)
- **Token Quota**: Monthly per-installation limits prevent cost overruns
- **Graceful Shutdown**: Clean Redis disconnect on SIGTERM/SIGINT
- **Structured Logging**: JSON logs in production, human-readable in dev
- **Health Checks**: `/health` endpoint for load balancers

## Project Structure

```
src/
├── index.ts               # Express server, webhooks, health check
├── env.ts                 # Environment variable configuration
├── redis.ts               # Redis client singleton (token quota)
├── logger.ts              # Structured JSON logging
├── analysis/
│   ├── analyzer.ts        # Main analysis orchestration
│   ├── ast.ts             # AST analysis coordinator
│   ├── ast/               # Language-specific AST analyzers
│   │   ├── typescript.ts  # TypeScript/JavaScript (ts-morph)
│   │   ├── python.ts      # Python (tree-sitter)
│   │   ├── go.ts          # Go (tree-sitter)
│   │   └── ruby.ts        # Ruby (tree-sitter)
│   ├── patterns.ts        # Regex pattern constants
│   ├── helpers.ts         # Analysis helper functions
│   ├── rules.ts           # Rule definitions and types
│   ├── scoring.ts         # Vibe Score computation
│   └── structure.ts       # Code structure extraction
├── config/
│   ├── schema.ts          # VibeScaleConfig type definitions
│   ├── loader.ts          # .vibescale.yml loading
│   └── suppression.ts     # Inline suppression parsing
└── integrations/
    ├── github.ts          # GitHub App webhook handlers
    └── llm.ts             # Groq LLM integration + quota

Deployment:
├── Dockerfile             # Multi-stage Docker build
├── railway.toml           # Railway configuration
└── .dockerignore
```

## Supported File Types

Code analysis runs on: `.ts`, `.tsx`, `.js`, `.jsx`, `.py`, `.go`, `.rb`, `.java`, `.cs`

Non-code files (`.md`, `.json`, `.yml`, etc.) are automatically skipped.

## License

ISC
